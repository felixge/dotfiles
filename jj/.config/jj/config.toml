[user]
name = "Felix Geisend√∂rfer"
email = "felix@felixge.de"

[[--scope]]
--when.repositories = ["~/go/src/github.com/DataDog", "~/go/src/github.com/golang/go", "~/go/src/github.com/open-telemetry", "~/go/src/golang.org"]
[--scope.user]
email = "felix.geisendoerfer@datadoghq.com"

[templates]
draft_commit_description = '''
concat(
  coalesce(description, "\n"),
  surround(
    "\nJJ: This commit contains the following changes:\n", "",
    indent("JJ:     ", diff.stat(72)),
  ),
  "\nJJ: ignore-rest\n",
  diff.git(),
)
'''
git_push_bookmark = """
  truncate_end(
    244,
    separate(
      "/",
      "felix.geisendoerfer",
      jira_issue_prefix(description),
      first_line_suffix(description),
    ),
  )
"""

[template-aliases]
'format_short_cryptographic_signature(sig)' = 'if(sig, "üîë", "‚ö†Ô∏è")'

'format_commit_type_emoji(description)' = '''
  separate(" ",
    if(description.match(regex:"private[(:]"), "üôä"),
    if(description.match(regex:"wip[(:]"), "üöß"),
    if(description.match(regex:"chore[(:]"), "üßπ"),
    if(description.match(regex:"fix[(:]"), "üêû"),
    if(description.match(regex:"feat[(:]"), "üéÅ"),
    if(description.match(regex:"refactor[(:]"), "‚ôªÔ∏è"),
  )
'''

'builtin_log_compact(commit)' = '''
if(commit.root(),
  format_root_commit(commit),
  label(
    separate(" ",
      if(commit.current_working_copy(), "working_copy"),
      if(commit.immutable(), "immutable", "mutable"),
      if(commit.conflict(), "conflicted"),
    ),
    concat(
      format_short_commit_header(commit) ++ "\n",
      separate(" ",
        if(commit.empty(), empty_commit_marker),
        if(commit.description(),
          separate(" ",
            format_commit_type_emoji(commit.description()),
            commit.description().first_line(),
          ),
          label(if(commit.empty(), "empty"), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''

"first_line_suffix(description)" = """
  description
    .first_line()
    .remove_prefix(jira_issue_prefix(description))
    .lower()
    .replace(regex:"[[:^word:]]", "-")
    .replace(regex:"-+", "-")
    .replace(regex:"^-|-$", "")
"""

"jira_issue_prefix(description)" = """
  description
    .match(regex:"^[[:upper:]]+-[[:digit:]]+[[:blank:]]+")
    .replace(regex:"[[:blank:]]+", "")
"""

[revsets]
log-graph-prioritize = 'coalesce(megamerge(), trunk())'

[revset-aliases]
'closest_bookmark(to)' = 'heads(::to & bookmarks())'
'wip' = '((trunk()..@):: & mine()) | trunk()'
#'stack' = 'fork_point(@ | trunk())::@'
"mine()" = """
    author(exact:'felix@felixge.de')
  | author(exact:'felix@datadoghq.com')
  | author(exact:'felix.geisendoerfer@datadoghq.com')
  | author(exact:'haimuiba@gmail.com')
"""

# stack(x, n) is the set of mutable commits reachable from 'x', with 'n'
# parents. 'n' is often useful to customize the display and return set for
# certain operations. 'x' can be used to target the set of 'roots' to traverse,
# e.g. @ is the current stack.
'stack()' = 'stack(@)'
'stack(x)' = 'stack(x, 2)'
'stack(x, n)' = 'ancestors(reachable(x, mutable()), n)'

'megamerge()' = 'coalesce(present(megamerge), reachable(stack(), merges()))'

[aliases]
wip = ["log", "-r", "wip"]
e = ["edit"]
# bring nearest bookmark up to recent commit
tug = ["bookmark", "move", "--from", "closest_bookmark(@-)", "--to", "@-"]
body = ["show", "--no-patch", "-T", "description.remove_prefix(description.first_line()).trim_start()"]
stack = ["log", "--no-graph", "-r", "stack"]
# open pr for nearest bookmark
pr = ["util", "exec", "--", "bash", "-c", """
ref=${1:-@-}
gh pr view --web "$(jj bookmark list -r 'closest_bookmark('$ref')' -T 'name')"
""", ""]

[ui]
default-command = ["log"]
bookmark-list-sort-keys = ["committer-date-"]
show-cryptographic-signatures = true
pager = "delta"
diff-formatter = ":git"
diff-editor = ":builtin"

[signing]
behavior = "own"
backend = "ssh"
key = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGjTWhql3FHsAAAZWolVjmZzNX5xxXByRb7RX2sgnC1h felix.geisendoerfer+git-commit-signing@datadoghq.com"

[git]
push-branch-prefix = "felixge/push-"
private-commits = '''description(glob:'private:*')'''

[fsmonitor]
backend = "watchman"
[fsmonitor.watchman]
register-snapshot-trigger = true

